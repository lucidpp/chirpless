<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chirpless - Infinite & Cinematic</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=VT323&display=swap');
        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'VT323', monospace; user-select: none; }
        
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; display: flex; flex-direction: column; justify-content: space-between; z-index: 10; }
        
        /* HUD */
        #hud-top { padding: 20px; display: flex; justify-content: space-between; align-items: flex-start; pointer-events: none; }
        #hud-left { display: flex; flex-direction: column; gap: 10px; }
        .stat-row { display: flex; gap: 5px; }
        .heart, .shield { width: 24px; height: 24px; image-rendering: pixelated; filter: drop-shadow(2px 2px 0 #000); }
        #time-display { color: white; font-size: 24px; text-shadow: 2px 2px 0 #000; background: rgba(0,0,0,0.3); padding: 5px 10px; border-radius: 4px; width: fit-content; }
        
        /* MINIMAP */
        #minimap-container {
            width: 130px; height: 130px;
            border: 4px solid #333;
            background: rgba(0,0,0,0.6);
            border-radius: 50%;
            overflow: hidden;
            position: relative;
            box-shadow: 0 4px 10px rgba(0,0,0,0.5);
            backdrop-filter: blur(2px);
        }
        #minimap { width: 100%; height: 100%; image-rendering: pixelated; }
        #minimap-arrow {
            position: absolute; top: 50%; left: 50%; width: 0; height: 0;
            border-left: 6px solid transparent; border-right: 6px solid transparent; border-bottom: 10px solid white;
            transform: translate(-50%, -50%); z-index: 2; filter: drop-shadow(0 1px 2px black);
        }

        #crosshair {
            position: absolute; top: 50%; left: 50%; width: 24px; height: 24px;
            background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path d="M11 0h2v24h-2zM0 11h24v2h-24z" fill="white" fill-opacity="0.9"/></svg>');
            transform: translate(-50%, -50%); mix-blend-mode: difference; z-index: 10; opacity: 0.8;
        }

        #hotbar-container { display: flex; flex-direction: column; align-items: center; padding-bottom: 15px; width: 100%; }
        #hotbar { display: flex; gap: 8px; background: rgba(0,0,0,0.6); padding: 8px; border-radius: 8px; overflow-x: auto; max-width: 90%; pointer-events: auto; backdrop-filter: blur(2px); border: 1px solid rgba(255,255,255,0.1); }
        #hotbar::-webkit-scrollbar { height: 6px; }
        #hotbar::-webkit-scrollbar-thumb { background: #555; border-radius: 4px; }
        
        .slot {
            min-width: 54px; min-height: 54px; background: #8b8b8b; border: 3px solid #373737;
            display: flex; justify-content: center; align-items: center; position: relative; cursor: pointer; transition: transform 0.1s, border-color 0.1s;
        }
        .slot.active { border-color: white; background: #a0a0a0; transform: scale(1.1); box-shadow: 0 0 15px rgba(255,255,255,0.4); z-index: 2; }
        .slot:hover { border-color: #bbb; }
        .item-icon { width: 36px; height: 36px; image-rendering: pixelated; box-shadow: 2px 2px 0 rgba(0,0,0,0.3); }

        /* MENU STYLES */
        #main-menu {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            z-index: 20; pointer-events: auto;
            background: rgba(0,0,0,0.3); /* Transparent to see world */
            color: white;
            backdrop-filter: blur(3px);
            transition: opacity 0.5s;
        }
        .logo { 
            font-size: 120px; color: white; text-shadow: 0 5px 0 #222, 0 10px 20px rgba(0,0,0,0.5); margin-bottom: 20px; 
            animation: float 4s ease-in-out infinite; font-weight: bold; letter-spacing: 5px;
        }
        @keyframes float { 0%, 100% { transform: translateY(0); } 50% { transform: translateY(-15px); } }
        
        .menu-box {
            background: rgba(0,0,0,0.6); padding: 40px; border-radius: 16px; border: 2px solid rgba(255,255,255,0.1);
            display: flex; flex-direction: column; gap: 20px; width: 350px; text-align: center;
            box-shadow: 0 20px 50px rgba(0,0,0,0.5);
        }
        
        .menu-input {
            padding: 12px; font-size: 22px; font-family: inherit; text-align: center;
            background: rgba(0,0,0,0.5); border: 2px solid #555; color: white; border-radius: 6px;
        }
        .menu-input:focus { outline: none; border-color: #4caf50; background: rgba(0,0,0,0.7); }
        
        .menu-btn {
            padding: 15px; background: linear-gradient(to bottom, #4caf50, #388e3c); border: none; border-bottom: 5px solid #1b5e20;
            color: white; font-size: 28px; cursor: pointer; font-family: inherit; border-radius: 6px; transition: all 0.1s;
            text-shadow: 1px 1px 0 rgba(0,0,0,0.5);
        }
        .menu-btn:hover { filter: brightness(1.1); transform: translateY(-2px); }
        .menu-btn:active { transform: translateY(2px); border-bottom-width: 0; margin-bottom: 5px; }

        #pet-msg {
            position: absolute; bottom: 140px; width: 100%; text-align: center;
            color: #ffd700; font-size: 28px; text-shadow: 2px 2px 0 #000; opacity: 0; transition: opacity 0.3s;
            pointer-events: none;
        }
        
        /* ICONS */
        .icon-grass { background: linear-gradient(#5d9e44 50%, #5c4033 50%); }
        .icon-dirt { background: #5c4033; }
        .icon-stone { background: #757575; }
        .icon-wood { background: repeating-linear-gradient(90deg, #4e342e, #4e342e 5px, #3e2723 5px, #3e2723 10px); }
        .icon-leaves { background: radial-gradient(#4caf50, #2e7d32); }
        .icon-sand { background: #f4a460; }
        .icon-gravel { background: #9e9e9e; background-image: radial-gradient(#555 1px, transparent 1px); background-size: 5px 5px; }
        .icon-water { background: #2196f3; opacity: 0.8; }
        .icon-gold_ore { background: #757575; border: 4px dotted #ffd700; }
        .icon-diamond_ore { background: #757575; border: 4px dotted #00bfff; }
        .icon-pumpkin { background: #ff9800; border-top: 4px solid #4caf50; }
        .icon-jack_o_lantern { background: #ff9800; box-shadow: 0 0 10px #ff9800; }
        .icon-tnt { background: repeating-linear-gradient(45deg, #f44336, #f44336 10px, #fff 10px, #fff 12px); }
        .icon-present { background: #f44336; border: 4px solid #4caf50; }
        .icon-ice { background: #b3e5fc; opacity: 0.7; }
        .icon-glowstone { background: #ffeb3b; box-shadow: 0 0 10px #ffeb3b; }
        .icon-cactus { background: #4caf50; border-left: 2px dashed #2e7d32; }
    </style>
</head>
<body>

    <div id="ui-layer">
        <div id="hud-top">
            <div id="hud-left">
                <div class="stat-row" id="health-bar"></div>
                <div class="stat-row" id="armor-bar"></div>
                <div id="time-display">Day 1 - 12:00 PM</div>
            </div>
            
            <div id="minimap-container">
                <canvas id="minimap" width="60" height="60"></canvas>
                <div id="minimap-arrow"></div>
            </div>
        </div>
        
        <div id="pet-msg">Press 'E' to Pet Chirp</div>
        <div id="hotbar-container">
            <div id="hotbar"></div>
        </div>
    </div>

    <div id="crosshair"></div>

    <div id="main-menu">
        <div class="logo">CHIRPLESS</div>
        <div class="menu-box">
            <div style="color:#ddd; font-size: 18px;">ENTER WORLD SEED</div>
            <input type="text" id="seed-input" class="menu-input" placeholder="e.g. 12345" value="12345">
            <button class="menu-btn" onclick="startGame()">ENTER WORLD</button>
            <div style="font-size: 14px; color: #aaa; margin-top: 10px;">WASD to Move â€¢ Click to Build</div>
        </div>
    </div>

    <!-- THREE.JS -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <script>
        // --- PRNG (Seeded Random) ---
        class PseudoRandom {
            constructor(seed) {
                this.seed = (parseInt(seed) || 12345) % 2147483647;
                if (this.seed <= 0) this.seed += 2147483646;
            }
            next() {
                this.seed = (this.seed * 16807) % 2147483647;
                return (this.seed - 1) / 2147483646;
            }
        }
        let rng = new PseudoRandom(12345);

        // --- ASSETS ---
        function genTex(color, type='noise') {
            const cvs = document.createElement('canvas');
            cvs.width = 64; cvs.height = 64;
            const ctx = cvs.getContext('2d');
            ctx.fillStyle = color; ctx.fillRect(0,0,64,64);
            
            if (type==='noise') {
                for(let i=0; i<400; i++) {
                    ctx.fillStyle = `rgba(0,0,0,${Math.random()*0.15})`;
                    ctx.fillRect(Math.random()*64, Math.random()*64, 2, 2);
                }
            } else if (type==='brick') {
                ctx.fillStyle = 'rgba(0,0,0,0.2)';
                for(let y=0; y<64; y+=16) {
                    ctx.fillRect(0,y,64,2);
                    let o = (y/16)%2===0?0:32;
                    for(let x=o; x<64; x+=32) ctx.fillRect(x,y,2,16);
                }
            } else if (type==='ore') {
                for(let i=0; i<10; i++) {
                    ctx.fillStyle = `rgba(0,0,0,0.3)`;
                    let s = Math.random()*10+5;
                    ctx.fillRect(Math.random()*50, Math.random()*50, s, s);
                    ctx.fillStyle = color;
                    ctx.fillRect(Math.random()*50, Math.random()*50, s-4, s-4);
                }
                ctx.globalCompositeOperation = 'destination-over';
                ctx.fillStyle = '#757575'; ctx.fillRect(0,0,64,64);
            } else if (type==='face') {
                 ctx.fillStyle = '#3e2723';
                 ctx.beginPath();
                 ctx.moveTo(10,20); ctx.lineTo(20,10); ctx.lineTo(30,20); ctx.fill(); 
                 ctx.moveTo(34,20); ctx.lineTo(44,10); ctx.lineTo(54,20); ctx.fill();
                 ctx.moveTo(10,40); ctx.lineTo(15,50); ctx.lineTo(25,45); ctx.lineTo(35,50); ctx.lineTo(45,45); ctx.lineTo(54,50); ctx.lineTo(54,40); ctx.fill();
            }
            const tex = new THREE.CanvasTexture(cvs); tex.magFilter = THREE.NearestFilter; return tex;
        }

        const TEX = {
            grass_top: genTex('#5d9e44'), grass_side: genTex('#5d9e44'), dirt: genTex('#5c4033'),
            stone: genTex('#757575'), sand: genTex('#f4a460'), gravel: genTex('#9e9e9e'),
            wood: genTex('#4e342e', 'brick'), leaves: genTex('#2e7d32'),
            water: genTex('#2196f3', 'flat'), ice: genTex('#b3e5fc', 'noise'),
            snow: genTex('#fffafa', 'flat'), cactus: genTex('#43a047', 'brick'),
            brick: genTex('#8d6e63', 'brick'), glass: genTex('#e0f7fa', 'flat'),
            gold: genTex('#ffd700', 'ore'), iron: genTex('#d7ccc8', 'ore'), 
            diamond: genTex('#00bfff', 'ore'), coal: genTex('#212121', 'ore'),
            obsidian: genTex('#1a237e'), tnt: genTex('#f44336', 'brick'),
            pumpkin_side: genTex('#fb8c00', 'brick'), pumpkin_face: genTex('#fb8c00', 'face'),
            jack: genTex('#ffeb3b', 'face'), glowstone: genTex('#ffeb3b'),
            present_red: genTex('#d32f2f'), present_green: genTex('#388e3c'),
            candy: genTex('#ffcdd2', 'brick'), clay: genTex('#90a4ae'),
            wool_r: genTex('#e53935'), wool_g: genTex('#43a047'), wool_b: genTex('#1e88e5')
        };
        // Fix grass side for better look
        const gsc = document.createElement('canvas'); gsc.width=64; gsc.height=64;
        const gcx = gsc.getContext('2d');
        gcx.fillStyle='#5c4033'; gcx.fillRect(0,0,64,64);
        gcx.fillStyle='#5d9e44'; gcx.fillRect(0,0,64,20);
        for(let i=0;i<12;i++) gcx.fillRect(Math.random()*60, 20, 4, Math.random()*8);
        TEX.grass_side = new THREE.CanvasTexture(gsc); TEX.grass_side.magFilter=THREE.NearestFilter;

        const BLOCKS = [
            { id: 0, name: 'Air', col: '#000000' },
            { id: 1, name: 'Grass', tex: [TEX.grass_side, TEX.grass_side, TEX.grass_top, TEX.dirt, TEX.grass_side, TEX.grass_side], icon:'icon-grass', col: '#5d9e44' },
            { id: 2, name: 'Dirt', tex: TEX.dirt, icon:'icon-dirt', col: '#5c4033' },
            { id: 3, name: 'Stone', tex: TEX.stone, icon:'icon-stone', col: '#757575' },
            { id: 4, name: 'Wood', tex: TEX.wood, icon:'icon-wood', col: '#4e342e' },
            { id: 5, name: 'Leaves', tex: TEX.leaves, icon:'icon-leaves', col: '#2e7d32' },
            { id: 6, name: 'Sand', tex: TEX.sand, icon:'icon-sand', col: '#f4a460' },
            { id: 7, name: 'Gravel', tex: TEX.gravel, icon:'icon-gravel', col: '#9e9e9e' },
            { id: 8, name: 'Water', tex: TEX.water, trans: true, icon:'icon-water', col: '#2196f3' },
            { id: 9, name: 'Gold Ore', tex: TEX.gold, icon:'icon-gold_ore', col: '#ffd700' },
            { id: 10, name: 'Iron Ore', tex: TEX.iron, icon:'icon-iron_ore', col: '#d7ccc8' },
            { id: 11, name: 'Coal Ore', tex: TEX.coal, icon:'icon-coal_ore', col: '#212121' },
            { id: 12, name: 'Diamond Ore', tex: TEX.diamond, icon:'icon-diamond_ore', col: '#00bfff' },
            { id: 13, name: 'Obsidian', tex: TEX.obsidian, icon:'icon-obsidian', col: '#1a237e' },
            { id: 14, name: 'TNT', tex: TEX.tnt, icon:'icon-tnt', col: '#f44336' },
            { id: 15, name: 'Pumpkin', tex: [TEX.pumpkin_side, TEX.pumpkin_side, TEX.pumpkin_side, TEX.pumpkin_side, TEX.pumpkin_face, TEX.pumpkin_side], icon:'icon-pumpkin', col: '#fb8c00' },
            { id: 16, name: 'Jack-o-Lantern', tex: [TEX.pumpkin_side, TEX.pumpkin_side, TEX.pumpkin_side, TEX.pumpkin_side, TEX.jack, TEX.pumpkin_side], light: 0xffff00, icon:'icon-jack_o_lantern', col: '#fb8c00' },
            { id: 17, name: 'Glowstone', tex: TEX.glowstone, light: 0xffaa00, icon:'icon-glowstone', col: '#ffeb3b' },
            { id: 18, name: 'Red Wool', tex: TEX.wool_r, icon:'icon-present', col: '#e53935' },
            { id: 19, name: 'Green Wool', tex: TEX.wool_g, icon:'icon-present', col: '#43a047' },
            { id: 20, name: 'Blue Wool', tex: TEX.wool_b, icon:'icon-present', col: '#1e88e5' },
            { id: 21, name: 'Snow', tex: TEX.snow, icon:'icon-ice', col: '#fffafa' },
            { id: 22, name: 'Ice', tex: TEX.ice, trans: true, icon:'icon-ice', col: '#b3e5fc' },
            { id: 23, name: 'Cactus', tex: TEX.cactus, icon:'icon-cactus', col: '#43a047' },
            { id: 24, name: 'Clay', tex: TEX.clay, icon:'icon-clay', col: '#90a4ae' },
            { id: 25, name: 'Present (Red)', tex: TEX.present_red, icon:'icon-present', col: '#d32f2f' },
            { id: 26, name: 'Present (Green)', tex: TEX.present_green, icon:'icon-present', col: '#388e3c' },
            { id: 27, name: 'Candy Cane', tex: TEX.candy, icon:'icon-present', col: '#ffcdd2' },
            { id: 28, name: 'Glass', tex: TEX.glass, trans: true, icon:'icon-glass', col: '#e0f7fa' },
            { id: 29, name: 'Bricks', tex: TEX.brick, icon:'icon-brick', col: '#8d6e63' }
        ];

        // --- THREE JS INIT ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87CEEB);
        scene.fog = new THREE.Fog(0x87CEEB, 20, 60);
        
        const camera = new THREE.PerspectiveCamera(70, window.innerWidth/window.innerHeight, 0.1, 100);
        const renderer = new THREE.WebGLRenderer({ antialias: false });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        document.body.appendChild(renderer.domElement);

        const ambLight = new THREE.AmbientLight(0xffffff, 0.5);
        scene.add(ambLight);
        const sunLight = new THREE.DirectionalLight(0xffffff, 1.0);
        sunLight.position.set(50, 100, 50);
        sunLight.castShadow = true;
        sunLight.shadow.mapSize.width = 2048;
        sunLight.shadow.mapSize.height = 2048;
        scene.add(sunLight);

        // Stars
        const starGeo = new THREE.BufferGeometry();
        const starPos = [];
        for(let i=0; i<3000; i++) starPos.push((Math.random()-0.5)*200);
        starGeo.setAttribute('position', new THREE.Float32BufferAttribute(starPos, 3));
        const stars = new THREE.Points(starGeo, new THREE.PointsMaterial({color: 0xffffff, size: 0.5, transparent: true, opacity: 0}));
        scene.add(stars);

        // Player & Hand
        const player = new THREE.Group(); scene.add(player);
        const head = new THREE.Group(); head.position.y = 1.7; player.add(head); head.add(camera);
        const hand = new THREE.Mesh(new THREE.BoxGeometry(0.2,0.2,0.6), new THREE.MeshLambertMaterial({color:0xeebb99}));
        hand.position.set(0.3,-0.3,-0.5); head.add(hand);

        // Pet "Chirp"
        const chirp = new THREE.Group();
        chirp.add(new THREE.Mesh(new THREE.BoxGeometry(0.6, 0.6, 0.6), new THREE.MeshLambertMaterial({color: 0x2196f3}))); 
        const beak = new THREE.Mesh(new THREE.BoxGeometry(0.2, 0.1, 0.2), new THREE.MeshLambertMaterial({color: 0xff9800})); beak.position.set(0, 0.1, 0.3); chirp.add(beak);
        const eyes = new THREE.Mesh(new THREE.BoxGeometry(0.4,0.1,0.05), new THREE.MeshBasicMaterial({color:0x000000})); eyes.position.set(0, 0.2, 0.3); chirp.add(eyes);
        chirp.position.set(2, 10, 2); scene.add(chirp);

        // --- WORLD & CHUNKS ---
        const CHUNK_SIZE = 16;
        const RENDER_DIST = 2;
        const chunks = new Map();
        const blockData = new Map();
        const heightMap = new Map();
        const boxGeo = new THREE.BoxGeometry(1,1,1);
        const matCache = [];

        function getMat(id) {
            if (matCache[id]) return matCache[id];
            const b = BLOCKS[id];
            let m;
            if (Array.isArray(b.tex)) m = b.tex.map(t => new THREE.MeshLambertMaterial({map:t}));
            else m = new THREE.MeshLambertMaterial({map:b.tex, transparent:!!b.trans, opacity:b.trans?0.6:1});
            if(b.light) {
                const c = new THREE.Color(b.light);
                if(Array.isArray(m)) m.forEach(mt => { mt.emissive = c; mt.emissiveIntensity = 0.5; });
                else { m.emissive = c; m.emissiveIntensity = 0.5; }
            }
            matCache[id] = m;
            return m;
        }

        function createBlock(x,y,z,id) {
            const k = `${x},${y},${z}`;
            if(blockData.has(k)) return;
            const mesh = new THREE.Mesh(boxGeo, getMat(id));
            mesh.position.set(x,y,z); // Integer positions
            mesh.userData = { id: id, key: k };
            
            const ck = `${Math.floor(x/CHUNK_SIZE)},${Math.floor(z/CHUNK_SIZE)}`;
            if(!chunks.has(ck)) chunks.set(ck, []);
            chunks.get(ck).push(mesh);
            scene.add(mesh);
            blockData.set(k, mesh);
            
            const hKey = `${x},${z}`;
            const curr = heightMap.get(hKey);
            if (!curr || y >= curr.y) heightMap.set(hKey, {y: y, id: id});

            if(BLOCKS[id].light) {
                const l = new THREE.PointLight(BLOCKS[id].light, 1, 8);
                l.position.set(x,y,z); scene.add(l); mesh.userData.light = l;
            }
        }

        function genChunk(cx, cz) {
            for(let x = cx*CHUNK_SIZE; x < (cx+1)*CHUNK_SIZE; x++) {
                for(let z = cz*CHUNK_SIZE; z < (cz+1)*CHUNK_SIZE; z++) {
                    let n = Math.sin(x/10)*4 + Math.cos(z/12)*4 + (Math.sin(x/30)*10);
                    n += rng.next() * 2; 
                    let h = Math.floor(n);
                    
                    let biome = 'plains';
                    if (h > 8) biome = 'mountain';
                    if (h < -2) biome = 'desert';

                    createBlock(x, -5, z, 3);
                    for(let y=-4; y<=h; y++) {
                        let id = 3; 
                        if (y===h) {
                            if(biome==='desert') id=6; else if(biome==='mountain') id=21; else id=1;
                        } else if (y>h-3) {
                            if(biome==='desert') id=6; else id=2;
                        } else {
                             if(rng.next()<0.01) id=11; else if(rng.next()<0.005) id=10;
                        }
                        createBlock(x,y,z,id);
                    }
                    if(h===Math.floor(h) && rng.next()<0.02) {
                        if(biome==='plains') {
                            for(let i=1;i<5;i++) createBlock(x,h+i,z,4);
                            for(let lx=x-2;lx<=x+2;lx++) for(let lz=z-2;lz<=z+2;lz++) for(let ly=h+3;ly<=h+5;ly++) if(Math.abs(lx-x)+Math.abs(lz-z)+Math.abs(ly-(h+4))<=2) createBlock(lx,ly,lz,5);
                        } else if(biome==='desert') for(let i=1;i<4;i++) createBlock(x,h+i,z,23);
                    }
                }
            }
        }

        function updateChunks() {
            const pcx = Math.floor(player.position.x / CHUNK_SIZE);
            const pcz = Math.floor(player.position.z / CHUNK_SIZE);
            for(let x = pcx - RENDER_DIST; x <= pcx + RENDER_DIST; x++) {
                for(let z = pcz - RENDER_DIST; z <= pcz + RENDER_DIST; z++) {
                    if(!chunks.has(`${x},${z}`)) genChunk(x, z);
                }
            }
            // Simple unload
            for(let [k, meshes] of chunks) {
                const [cx, cz] = k.split(',').map(Number);
                if (Math.abs(cx - pcx) > RENDER_DIST + 1 || Math.abs(cz - pcz) > RENDER_DIST + 1) {
                    meshes.forEach(m => {
                        scene.remove(m); if(m.userData.light) scene.remove(m.userData.light);
                        blockData.delete(m.userData.key);
                    });
                    chunks.delete(k);
                }
            }
        }

        // --- MINIMAP ---
        const mapCvs = document.getElementById('minimap');
        const mapCtx = mapCvs.getContext('2d');
        
        function updateMinimap() {
            mapCtx.fillStyle = '#000'; mapCtx.fillRect(0,0,60,60);
            const range = 25; 
            const px = Math.floor(player.position.x);
            const pz = Math.floor(player.position.z);
            for(let z = -range; z <= range; z++) {
                for(let x = -range; x <= range; x++) {
                    const info = heightMap.get(`${px+x},${pz+z}`);
                    if(info) {
                        const b = BLOCKS[info.id];
                        if(b && b.col) {
                            mapCtx.fillStyle = b.col;
                            mapCtx.fillRect(30 + x, 30 + z, 1, 1);
                        }
                    }
                }
            }
        }

        // --- DAY/NIGHT & ATMOSPHERE ---
        let timeOfDay = 0.3; 
        
        function updateSky(dt) {
            timeOfDay += dt / 240; // 4 min cycle
            if(timeOfDay > 1) timeOfDay = 0;

            const sunH = Math.sin((timeOfDay - 0.25) * Math.PI * 2);
            
            let skyHex = 0x87CEEB; // Day
            let fogHex = 0x87CEEB;
            let lightInt = 1.0;
            let ambInt = 0.6;
            let fogNear = 20, fogFar = 60;

            if (sunH < -0.1) { // Night
                skyHex = 0x02020a;
                fogHex = 0x02020a;
                lightInt = 0.05;
                ambInt = 0.3; // Visible but dark
                fogNear = 10; fogFar = 40;
            } else if (sunH < 0.2) { // Sunrise/Sunset
                skyHex = 0xff8c00; // Orange
                fogHex = 0xffa07a; // Salmon
                lightInt = (sunH + 0.2) * 2;
                ambInt = 0.5;
            }

            const targetSky = new THREE.Color(skyHex);
            scene.background.lerp(targetSky, dt * 2);
            if(scene.fog) {
                scene.fog.color.copy(scene.background);
                scene.fog.near = THREE.MathUtils.lerp(scene.fog.near, fogNear, dt);
                scene.fog.far = THREE.MathUtils.lerp(scene.fog.far, fogFar, dt);
            }
            
            sunLight.position.y = sunH * 100;
            sunLight.position.x = Math.cos((timeOfDay-0.25)*Math.PI*2) * 100;
            sunLight.intensity = lightInt;
            ambLight.intensity = ambInt;
            
            stars.material.opacity = (sunH < 0) ? Math.min(1, -sunH * 3) : 0;
            
            // Clock UI
            let h = Math.floor(timeOfDay * 24);
            let m = Math.floor((timeOfDay * 24 * 60) % 60);
            let ampm = h >= 12 ? 'PM' : 'AM';
            h = h % 12; h = h ? h : 12; 
            document.getElementById('time-display').innerText = `Day 1 - ${h}:${m.toString().padStart(2,'0')} ${ampm}`;
        }

        // --- GAMEPLAY ---
        let chirpState = 'follow';
        function updateChirp(dt) {
            const dist = player.position.distanceTo(chirp.position);
            if (chirpState === 'follow' && dist > 3) {
                const dir = new THREE.Vector3().subVectors(player.position, chirp.position).normalize();
                chirp.position.addScaledVector(dir, dt * 4);
                chirp.lookAt(player.position);
                const gy = getGroundY(chirp.position.x, chirp.position.z);
                chirp.position.y = gy + Math.abs(Math.sin(Date.now()/150)) * 0.5;
            } else {
                 const gy = getGroundY(chirp.position.x, chirp.position.z);
                 chirp.position.y = gy;
            }
        }

        function getGroundY(x, z) {
            const h = heightMap.get(`${Math.round(x)},${Math.round(z)}`);
            return h ? h.y + 1.3 : 0;
        }

        // Inputs
        const keys = {};
        document.onkeydown = e => keys[e.code] = true;
        document.onkeyup = e => keys[e.code] = false;
        
        let vy = 0; let onGround = false;
        function updatePhysics(dt) {
            const speed = 8;
            const dir = new THREE.Vector3();
            const fwd = new THREE.Vector3(0,0,-1).applyQuaternion(player.quaternion);
            const right = new THREE.Vector3(1,0,0).applyQuaternion(player.quaternion);
            if(keys['KeyW']) dir.add(fwd); if(keys['KeyS']) dir.sub(fwd);
            if(keys['KeyA']) dir.sub(right); if(keys['KeyD']) dir.add(right);
            if(dir.lengthSq()>0) player.position.addScaledVector(dir.normalize(), speed*dt);
            
            vy -= 28 * dt; 
            player.position.y += vy * dt;
            const gy = getGroundY(player.position.x, player.position.z);
            if(player.position.y < gy) { player.position.y = gy; vy = 0; onGround = true; } else onGround = false;
            if(keys['Space'] && onGround) { vy = 10; onGround = false; }
            if(player.position.y < -30) player.position.set(0, 30, 0);
            
            // Map rotate
            const deg = -player.rotation.y * (180/Math.PI);
            document.getElementById('minimap-arrow').style.transform = `translate(-50%, -50%) rotate(${deg}deg)`;
        }

        // Mouse
        let selBlock = null;
        const raycaster = new THREE.Raycaster(); raycaster.far = 6;
        document.onmousedown = e => {
            if(!isPlaying) return;
            if(!document.pointerLockElement) { requestSafePointerLock(); return; }
            
            hand.rotation.x = -0.5; setTimeout(()=>hand.rotation.x=0, 100);
            if(selBlock) {
                if(e.button === 0) {
                    scene.remove(selBlock.object);
                    if(selBlock.object.userData.light) scene.remove(selBlock.object.userData.light);
                    blockData.delete(selBlock.object.userData.key);
                } else if(e.button === 2) {
                    // FIXED: Simple integer math for grid alignment
                    // If we hit a face, the new block is simply the integer coords of the hit block + face normal
                    const bPos = selBlock.object.position;
                    const norm = selBlock.face.normal;
                    createBlock(bPos.x + norm.x, bPos.y + norm.y, bPos.z + norm.z, hotbar[selIdx]);
                }
            }
        }
        document.onmousemove = e => {
            if(document.pointerLockElement) {
                player.rotation.y -= e.movementX * 0.002;
                head.rotation.x -= e.movementY * 0.002;
                head.rotation.x = Math.max(-1.5, Math.min(1.5, head.rotation.x));
            }
        }

        // Setup Hotbar
        const hotbar = [1, 2, 3, 4, 15, 16, 17, 25, 27, 12, 14, 28];
        let selIdx = 0;
        const hbEl = document.getElementById('hotbar');
        hotbar.forEach((id, i) => {
            const d = document.createElement('div'); d.className = `slot ${i===0?'active':''}`;
            d.innerHTML = `<div class="item-icon ${BLOCKS[id].icon}"></div>`;
            d.onclick = () => { selIdx = i; updateHB(); };
            hbEl.appendChild(d);
        });
        function updateHB() { Array.from(hbEl.children).forEach((c,i) => c.classList.toggle('active', i===selIdx)); }
        document.addEventListener('wheel', e => { selIdx = (selIdx + Math.sign(e.deltaY) + hotbar.length) % hotbar.length; updateHB(); });

        // Loop
        let lastT = performance.now();
        let isPlaying = false; 
        let flyAngle = 0;

        function animate() {
            requestAnimationFrame(animate);
            const now = performance.now();
            const dt = Math.min((now - lastT)/1000, 0.1);
            lastT = now;

            updateSky(dt); // Sky always updates

            if(isPlaying) {
                updatePhysics(dt);
                updateChunks();
                updateChirp(dt);
                
                // Select
                raycaster.setFromCamera(new THREE.Vector2(0,0), camera);
                const hits = raycaster.intersectObjects(scene.children); 
                const blockHits = hits.filter(h => h.object.userData.id !== undefined);
                selBlock = blockHits.length > 0 ? blockHits[0] : null;

                updateMinimap();
                
                const chirpHit = raycaster.intersectObject(chirp, true);
                document.getElementById('pet-msg').style.opacity = (chirpHit.length>0 && chirpHit[0].distance<4) ? 1:0;
            } else {
                // Menu Fly Camera
                flyAngle += dt * 0.2;
                camera.position.x = Math.sin(flyAngle) * 30;
                camera.position.z = Math.cos(flyAngle) * 30;
                camera.position.y = 20;
                camera.lookAt(0, 5, 0);
                
                // Ensure chunks load for the flyover
                const cx = Math.floor(camera.position.x / CHUNK_SIZE);
                const cz = Math.floor(camera.position.z / CHUNK_SIZE);
                if(!chunks.has(`${cx},${cz}`)) genChunk(cx,cz);
            }
            
            renderer.render(scene, camera);
        }

        function requestSafePointerLock() {
            try { const p = document.body.requestPointerLock(); if(p) p.catch(e=>{}); } catch(e){}
        }

        // Initial Generation for Background
        rng = new PseudoRandom(12345);
        for(let x=-1;x<=1;x++) for(let z=-1;z<=1;z++) genChunk(x,z);
        animate();

        function startGame() {
            const seedVal = parseInt(document.getElementById('seed-input').value) || 12345;
            rng = new PseudoRandom(seedVal);
            
            document.getElementById('main-menu').style.opacity = 0;
            setTimeout(() => document.getElementById('main-menu').style.display = 'none', 500);
            document.getElementById('hud-top').style.pointerEvents = 'auto'; 
            
            // Reset world for new seed
            chunks.forEach(c => c.forEach(m => scene.remove(m)));
            chunks.clear(); blockData.clear(); heightMap.clear();
            
            // Generate starting area
            genChunk(0,0);
            
            // Transition Player
            player.position.set(0, 25, 0); 
            // We need to detach camera from "fly mode" (world space) and re-attach to head
            // ThreeJS camera is currently just being moved. 
            // In physics loop, we update PLAYER position. 
            // We need to ensure camera is child of head? Or we just copy pos?
            // The current setup: `head.add(camera)` was done at init.
            // But fly mode modifies `camera.position` directly in world space relative to parent (head).
            // We need to reset local transform.
            camera.position.set(0,0,0);
            camera.rotation.set(0,0,0);
            
            isPlaying = true;
            requestSafePointerLock();
            
            // Init Hearts
            document.getElementById('health-bar').innerHTML = new Array(5).fill('<img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxMCAxMCI+PHBhdGggZD0iTTIgMWgydjFoMlYxaDJ2M2wtMSAxdjFsLTEgMXYxbC0xIDF2MWgtMnYtMWwtMS0xdi0xbC0xLTF2LTFsLTEtMVYxeiIgZmlsbD0icmVkIiBzdHJva2U9ImJsYWNrIiBzdHJva2Utd2lkdGg9IjAuNSIvPjwvc3ZnPg==" class="heart">').join('');
        }
        
        window.onresize = () => { camera.aspect = window.innerWidth/window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); };
    </script>
</body>
</html>
