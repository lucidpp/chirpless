<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chirpless - Infinite & Festive</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=VT323&display=swap');
        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'VT323', monospace; user-select: none; }
        
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; display: flex; flex-direction: column; justify-content: space-between; }
        #hud-top { padding: 20px; display: flex; justify-content: space-between; align-items: flex-start; }
        .stat-row { display: flex; gap: 5px; margin-bottom: 5px; }
        .heart, .shield { width: 24px; height: 24px; image-rendering: pixelated; filter: drop-shadow(2px 2px 0 #000); }
        
        #time-display { color: white; font-size: 24px; text-shadow: 2px 2px 0 #000; background: rgba(0,0,0,0.3); padding: 5px 10px; border-radius: 4px; }
        
        #crosshair {
            position: absolute; top: 50%; left: 50%; width: 24px; height: 24px;
            background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path d="M11 0h2v24h-2zM0 11h24v2h-24z" fill="white" fill-opacity="0.8"/></svg>');
            transform: translate(-50%, -50%); mix-blend-mode: difference; z-index: 10;
        }

        #hotbar-container { display: flex; flex-direction: column; align-items: center; padding-bottom: 10px; width: 100%; }
        #hotbar { display: flex; gap: 6px; background: rgba(0,0,0,0.5); padding: 8px; border-radius: 8px; overflow-x: auto; max-width: 90%; pointer-events: auto; }
        /* Hide scrollbar */
        #hotbar::-webkit-scrollbar { height: 8px; }
        #hotbar::-webkit-scrollbar-thumb { background: #555; border-radius: 4px; }
        
        .slot {
            min-width: 48px; min-height: 48px; background: #8b8b8b; border: 3px solid #373737;
            display: flex; justify-content: center; align-items: center; position: relative; cursor: pointer;
        }
        .slot.active { border-color: white; background: #a0a0a0; transform: scale(1.05); box-shadow: 0 0 10px rgba(255,255,255,0.5); z-index: 2; }
        .slot-count { position: absolute; bottom: 2px; right: 4px; color: white; font-size: 18px; text-shadow: 2px 2px 0 #000; }
        .item-icon { width: 32px; height: 32px; image-rendering: pixelated; box-shadow: 2px 2px 0 rgba(0,0,0,0.3); }

        /* PROCEDURAL ICONS - CSS GENERATED */
        .icon-grass { background: linear-gradient(#5d9e44 50%, #5c4033 50%); }
        .icon-dirt { background: #5c4033; }
        .icon-stone { background: #757575; }
        .icon-wood { background: repeating-linear-gradient(90deg, #4e342e, #4e342e 5px, #3e2723 5px, #3e2723 10px); }
        .icon-leaves { background: radial-gradient(#4caf50, #2e7d32); }
        .icon-sand { background: #f4a460; }
        .icon-gravel { background: #9e9e9e; background-image: radial-gradient(#555 1px, transparent 1px); background-size: 5px 5px; }
        .icon-water { background: #2196f3; opacity: 0.8; }
        .icon-gold_ore { background: #757575; border: 4px dotted #ffd700; }
        .icon-diamond_ore { background: #757575; border: 4px dotted #00bfff; }
        .icon-pumpkin { background: #ff9800; border-top: 4px solid #4caf50; }
        .icon-jack_o_lantern { background: #ff9800; box-shadow: 0 0 10px #ff9800; }
        .icon-tnt { background: repeating-linear-gradient(45deg, #f44336, #f44336 10px, #fff 10px, #fff 12px); }
        .icon-present { background: #f44336; border: 4px solid #4caf50; }
        .icon-ice { background: #b3e5fc; opacity: 0.7; }
        .icon-glowstone { background: #ffeb3b; box-shadow: 0 0 10px #ffeb3b; }
        .icon-cactus { background: #4caf50; border-left: 2px dashed #2e7d32; }

        #main-menu, #pause-menu {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            z-index: 100; pointer-events: auto; background: rgba(0,0,0,0.8);
        }
        #pause-menu { display: none; }
        .logo { font-size: 80px; color: white; text-shadow: 4px 4px 0 #333; margin-bottom: 20px; }
        .menu-btn {
            width: 300px; padding: 15px; margin: 10px; background: #666; border: 3px solid #fff;
            color: white; font-size: 24px; cursor: pointer; font-family: inherit;
        }
        .menu-btn:hover { background: #888; transform: scale(1.05); }

        #pet-msg {
            position: absolute; bottom: 120px; width: 100%; text-align: center;
            color: yellow; font-size: 24px; text-shadow: 2px 2px 0 #000; opacity: 0; transition: opacity 0.3s;
        }
    </style>
</head>
<body>

    <div id="ui-layer">
        <div id="hud-top">
            <div id="hud-stats">
                <div class="stat-row" id="health-bar"></div>
                <div class="stat-row" id="armor-bar"></div>
            </div>
            <div id="time-display">Day 1 - 12:00 PM</div>
        </div>
        <div id="pet-msg">Press 'E' to Pet Chirp</div>
        <div id="hotbar-container">
            <div id="hotbar"></div>
        </div>
    </div>

    <div id="crosshair"></div>

    <div id="main-menu">
        <div class="logo">CHIRPLESS</div>
        <div style="color:#aaa; margin-bottom:20px;">Infinite World • Day/Night • Pets</div>
        <button class="menu-btn" onclick="startGame()">Start Game</button>
        <button class="menu-btn">Settings</button>
    </div>

    <!-- THREE.JS -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <script>
        // --- AUDIO SYSTEM (Web Audio API) ---
        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        
        function playSound(type) {
            if(audioCtx.state === 'suspended') audioCtx.resume();
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.connect(gain);
            gain.connect(audioCtx.destination);

            if (type === 'step') {
                osc.type = 'triangle';
                osc.frequency.setValueAtTime(100, audioCtx.currentTime);
                osc.frequency.exponentialRampToValueAtTime(50, audioCtx.currentTime + 0.05);
                gain.gain.setValueAtTime(0.1, audioCtx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.05);
                osc.start(); osc.stop(audioCtx.currentTime + 0.05);
            } else if (type === 'break') {
                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(150, audioCtx.currentTime);
                osc.frequency.exponentialRampToValueAtTime(40, audioCtx.currentTime + 0.1);
                gain.gain.setValueAtTime(0.2, audioCtx.currentTime);
                gain.gain.linearRampToValueAtTime(0, audioCtx.currentTime + 0.1);
                osc.start(); osc.stop(audioCtx.currentTime + 0.1);
            } else if (type === 'place') {
                osc.type = 'sine';
                osc.frequency.setValueAtTime(400, audioCtx.currentTime);
                osc.frequency.exponentialRampToValueAtTime(600, audioCtx.currentTime + 0.05);
                gain.gain.setValueAtTime(0.1, audioCtx.currentTime);
                gain.gain.linearRampToValueAtTime(0, audioCtx.currentTime + 0.05);
                osc.start(); osc.stop(audioCtx.currentTime + 0.05);
            } else if (type === 'chirp') {
                osc.type = 'sine';
                osc.frequency.setValueAtTime(800, audioCtx.currentTime);
                osc.frequency.linearRampToValueAtTime(1200, audioCtx.currentTime + 0.1);
                gain.gain.setValueAtTime(0.1, audioCtx.currentTime);
                gain.gain.linearRampToValueAtTime(0, audioCtx.currentTime + 0.2);
                osc.start(); osc.stop(audioCtx.currentTime + 0.2);
            }
        }

        // --- ASSETS & TEXTURES ---
        function genTex(color, type='noise') {
            const cvs = document.createElement('canvas');
            cvs.width = 64; cvs.height = 64;
            const ctx = cvs.getContext('2d');
            ctx.fillStyle = color; ctx.fillRect(0,0,64,64);
            
            if (type==='noise') {
                for(let i=0; i<400; i++) {
                    ctx.fillStyle = `rgba(0,0,0,${Math.random()*0.15})`;
                    ctx.fillRect(Math.random()*64, Math.random()*64, 2, 2);
                }
            } else if (type==='brick') {
                ctx.fillStyle = 'rgba(0,0,0,0.2)';
                for(let y=0; y<64; y+=16) {
                    ctx.fillRect(0,y,64,2);
                    let o = (y/16)%2===0?0:32;
                    for(let x=o; x<64; x+=32) ctx.fillRect(x,y,2,16);
                }
            } else if (type==='ore') {
                for(let i=0; i<10; i++) {
                    ctx.fillStyle = `rgba(0,0,0,0.3)`;
                    let s = Math.random()*10+5;
                    let x = Math.random()*50; let y = Math.random()*50;
                    ctx.fillRect(x,y,s,s);
                    ctx.fillStyle = color; // Ore color
                    ctx.fillRect(x+2,y+2,s-4,s-4);
                }
                ctx.globalCompositeOperation = 'destination-over';
                ctx.fillStyle = '#757575'; // Stone bg
                ctx.fillRect(0,0,64,64);
            } else if (type==='face') {
                 // Pumpkin face
                 ctx.fillStyle = '#3e2723';
                 ctx.beginPath();
                 ctx.moveTo(10,20); ctx.lineTo(20,10); ctx.lineTo(30,20); ctx.fill(); // Eye
                 ctx.moveTo(34,20); ctx.lineTo(44,10); ctx.lineTo(54,20); ctx.fill(); // Eye
                 ctx.moveTo(10,40); ctx.lineTo(15,50); ctx.lineTo(25,45); ctx.lineTo(35,50); ctx.lineTo(45,45); ctx.lineTo(54,50); ctx.lineTo(54,40); ctx.fill();
            }
            
            const tex = new THREE.CanvasTexture(cvs);
            tex.magFilter = THREE.NearestFilter;
            return tex;
        }

        const TEX = {
            grass_top: genTex('#5d9e44'), grass_side: genTex('#5d9e44'), dirt: genTex('#5c4033'),
            stone: genTex('#757575'), sand: genTex('#f4a460'), gravel: genTex('#9e9e9e'),
            wood: genTex('#4e342e', 'brick'), leaves: genTex('#2e7d32'),
            water: genTex('#2196f3', 'flat'), ice: genTex('#b3e5fc', 'noise'),
            snow: genTex('#fffafa', 'flat'), cactus: genTex('#43a047', 'brick'),
            brick: genTex('#8d6e63', 'brick'), glass: genTex('#e0f7fa', 'flat'),
            gold: genTex('#ffd700', 'ore'), iron: genTex('#d7ccc8', 'ore'), 
            diamond: genTex('#00bfff', 'ore'), coal: genTex('#212121', 'ore'),
            obsidian: genTex('#1a237e'), tnt: genTex('#f44336', 'brick'),
            pumpkin_side: genTex('#fb8c00', 'brick'), pumpkin_face: genTex('#fb8c00', 'face'),
            jack: genTex('#ffeb3b', 'face'), glowstone: genTex('#ffeb3b'),
            present_red: genTex('#d32f2f'), present_green: genTex('#388e3c'),
            candy: genTex('#ffcdd2', 'brick'), clay: genTex('#90a4ae'),
            wool_r: genTex('#e53935'), wool_g: genTex('#43a047'), wool_b: genTex('#1e88e5')
        };

        // Fix grass side
        const gsc = document.createElement('canvas'); gsc.width=64; gsc.height=64;
        const gcx = gsc.getContext('2d');
        gcx.fillStyle='#5c4033'; gcx.fillRect(0,0,64,64);
        gcx.fillStyle='#5d9e44'; gcx.fillRect(0,0,64,20);
        for(let i=0;i<12;i++) gcx.fillRect(Math.random()*60, 20, 4, Math.random()*8);
        TEX.grass_side = new THREE.CanvasTexture(gsc); TEX.grass_side.magFilter=THREE.NearestFilter;

        const BLOCKS = [
            { id: 0, name: 'Air' },
            { id: 1, name: 'Grass', tex: [TEX.grass_side, TEX.grass_side, TEX.grass_top, TEX.dirt, TEX.grass_side, TEX.grass_side], icon:'icon-grass' },
            { id: 2, name: 'Dirt', tex: TEX.dirt, icon:'icon-dirt' },
            { id: 3, name: 'Stone', tex: TEX.stone, icon:'icon-stone' },
            { id: 4, name: 'Wood', tex: TEX.wood, icon:'icon-wood' },
            { id: 5, name: 'Leaves', tex: TEX.leaves, icon:'icon-leaves' },
            { id: 6, name: 'Sand', tex: TEX.sand, icon:'icon-sand' },
            { id: 7, name: 'Gravel', tex: TEX.gravel, icon:'icon-gravel' },
            { id: 8, name: 'Water', tex: TEX.water, trans: true, icon:'icon-water' },
            { id: 9, name: 'Gold Ore', tex: TEX.gold, icon:'icon-gold_ore' },
            { id: 10, name: 'Iron Ore', tex: TEX.iron, icon:'icon-iron_ore' },
            { id: 11, name: 'Coal Ore', tex: TEX.coal, icon:'icon-coal_ore' },
            { id: 12, name: 'Diamond Ore', tex: TEX.diamond, icon:'icon-diamond_ore' },
            { id: 13, name: 'Obsidian', tex: TEX.obsidian, icon:'icon-obsidian' },
            { id: 14, name: 'TNT', tex: TEX.tnt, icon:'icon-tnt' },
            { id: 15, name: 'Pumpkin', tex: [TEX.pumpkin_side, TEX.pumpkin_side, TEX.pumpkin_side, TEX.pumpkin_side, TEX.pumpkin_face, TEX.pumpkin_side], icon:'icon-pumpkin' },
            { id: 16, name: 'Jack-o-Lantern', tex: [TEX.pumpkin_side, TEX.pumpkin_side, TEX.pumpkin_side, TEX.pumpkin_side, TEX.jack, TEX.pumpkin_side], light: 0xffff00, icon:'icon-jack_o_lantern' },
            { id: 17, name: 'Glowstone', tex: TEX.glowstone, light: 0xffaa00, icon:'icon-glowstone' },
            { id: 18, name: 'Red Wool', tex: TEX.wool_r, icon:'icon-present' },
            { id: 19, name: 'Green Wool', tex: TEX.wool_g, icon:'icon-present' },
            { id: 20, name: 'Blue Wool', tex: TEX.wool_b, icon:'icon-present' },
            { id: 21, name: 'Snow', tex: TEX.snow, icon:'icon-ice' },
            { id: 22, name: 'Ice', tex: TEX.ice, trans: true, icon:'icon-ice' },
            { id: 23, name: 'Cactus', tex: TEX.cactus, icon:'icon-cactus' },
            { id: 24, name: 'Clay', tex: TEX.clay, icon:'icon-clay' },
            { id: 25, name: 'Present (Red)', tex: TEX.present_red, icon:'icon-present' },
            { id: 26, name: 'Present (Green)', tex: TEX.present_green, icon:'icon-present' },
            { id: 27, name: 'Candy Cane', tex: TEX.candy, icon:'icon-present' },
            { id: 28, name: 'Glass', tex: TEX.glass, trans: true, icon:'icon-glass' },
            { id: 29, name: 'Bricks', tex: TEX.brick, icon:'icon-brick' }
        ];

        // --- THREE JS INIT ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87CEEB);
        scene.fog = new THREE.Fog(0x87CEEB, 30, 90); // Initialize Fog
        const camera = new THREE.PerspectiveCamera(70, window.innerWidth/window.innerHeight, 0.1, 100);
        const renderer = new THREE.WebGLRenderer({ antialias: false });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        document.body.appendChild(renderer.domElement);

        // Lighting
        const ambLight = new THREE.AmbientLight(0x404040, 0.5);
        scene.add(ambLight);
        const sunLight = new THREE.DirectionalLight(0xffffff, 1.0);
        sunLight.position.set(50, 100, 50);
        sunLight.castShadow = true;
        scene.add(sunLight);
        
        // Stars
        const starGeo = new THREE.BufferGeometry();
        const starPos = [];
        for(let i=0; i<1000; i++) starPos.push((Math.random()-0.5)*200, (Math.random()-0.5)*200 + 50, (Math.random()-0.5)*200);
        starGeo.setAttribute('position', new THREE.Float32BufferAttribute(starPos, 3));
        const stars = new THREE.Points(starGeo, new THREE.PointsMaterial({color: 0xffffff, size: 0.5, transparent: true, opacity: 0}));
        scene.add(stars);

        // Player
        const player = new THREE.Group();
        scene.add(player);
        const head = new THREE.Group();
        head.position.y = 1.7;
        player.add(head);
        head.add(camera);
        
        // Hand
        const hand = new THREE.Mesh(new THREE.BoxGeometry(0.2,0.2,0.6), new THREE.MeshLambertMaterial({color:0xeebb99}));
        hand.position.set(0.3,-0.3,-0.5); head.add(hand);

        // Pet "Chirp"
        const chirp = new THREE.Group();
        const cBody = new THREE.Mesh(new THREE.BoxGeometry(0.6, 0.6, 0.6), new THREE.MeshLambertMaterial({color: 0x2196f3}));
        cBody.position.y = 0.3;
        const cBeak = new THREE.Mesh(new THREE.BoxGeometry(0.2, 0.1, 0.2), new THREE.MeshLambertMaterial({color: 0xff9800}));
        cBeak.position.set(0, 0.4, 0.3);
        const cEye1 = new THREE.Mesh(new THREE.BoxGeometry(0.1,0.1,0.05), new THREE.MeshBasicMaterial({color:0x000000}));
        cEye1.position.set(-0.15, 0.5, 0.3);
        const cEye2 = cEye1.clone(); cEye2.position.set(0.15, 0.5, 0.3);
        chirp.add(cBody, cBeak, cEye1, cEye2);
        chirp.position.set(2, 10, 2);
        scene.add(chirp);

        // --- WORLD GENERATION (CHUNKS) ---
        const CHUNK_SIZE = 16;
        const RENDER_DIST = 2; // Chunks radius
        const chunks = new Map(); // "x,z" -> [meshes]
        const blockData = new Map(); // "x,y,z" -> typeId
        const activeLights = [];

        function getChunkKey(x, z) {
            return `${Math.floor(x/CHUNK_SIZE)},${Math.floor(z/CHUNK_SIZE)}`;
        }

        const boxGeo = new THREE.BoxGeometry(1,1,1);
        const matCache = [];

        function getMat(id) {
            if (matCache[id]) return matCache[id];
            const b = BLOCKS[id];
            let m;
            if (Array.isArray(b.tex)) m = b.tex.map(t => new THREE.MeshLambertMaterial({map:t}));
            else m = new THREE.MeshLambertMaterial({map:b.tex, transparent:!!b.trans, opacity:b.trans?0.6:1});
            
            // Emissive for lights
            if(b.light) {
                if(Array.isArray(m)) m.forEach(mt => { mt.emissive = new THREE.Color(b.light); mt.emissiveIntensity = 0.5; });
                else { m.emissive = new THREE.Color(b.light); m.emissiveIntensity = 0.5; }
            }
            matCache[id] = m;
            return m;
        }

        function createBlock(x,y,z,id) {
            const k = `${x},${y},${z}`;
            if(blockData.has(k)) return;
            
            const mesh = new THREE.Mesh(boxGeo, getMat(id));
            mesh.position.set(x,y,z);
            mesh.userData = { id: id, key: k };
            
            // Chunk mgmt
            const ck = getChunkKey(x,z);
            if(!chunks.has(ck)) chunks.set(ck, []);
            chunks.get(ck).push(mesh);
            
            scene.add(mesh);
            blockData.set(k, mesh);

            // Light logic
            if(BLOCKS[id].light) {
                const l = new THREE.PointLight(BLOCKS[id].light, 1, 8);
                l.position.set(x,y,z);
                scene.add(l);
                mesh.userData.light = l;
            }
        }

        function genChunk(cx, cz) {
            for(let x = cx*CHUNK_SIZE; x < (cx+1)*CHUNK_SIZE; x++) {
                for(let z = cz*CHUNK_SIZE; z < (cz+1)*CHUNK_SIZE; z++) {
                    // Height noise
                    let h = Math.floor(Math.sin(x/10)*4 + Math.cos(z/12)*4 + (Math.sin(x/30)*10));
                    
                    // Biome?
                    let biome = 'plains';
                    if (h > 6) biome = 'mountain';
                    if (h < -2) biome = 'desert';

                    createBlock(x, -5, z, 3); // Bedrock/Base

                    for(let y=-4; y<=h; y++) {
                        let id = 3; // Stone default
                        if (y===h) {
                            if(biome==='desert') id=6; // Sand
                            else if(biome==='mountain') id=21; // Snow
                            else id=1; // Grass
                        } else if (y>h-3) {
                            if(biome==='desert') id=6; 
                            else id=2; // Dirt
                        } else {
                            // Ores
                            if(Math.random()<0.01) id=11; // Coal
                            else if(Math.random()<0.005) id=10; // Iron
                        }
                        createBlock(x,y,z,id);
                    }

                    // Decor
                    if(h===Math.floor(h) && Math.random()<0.02) {
                        if(biome==='plains') {
                            // Tree
                            for(let i=1;i<5;i++) createBlock(x,h+i,z,4);
                            for(let lx=x-2;lx<=x+2;lx++) for(let lz=z-2;lz<=z+2;lz++) for(let ly=h+3;ly<=h+5;ly++) if(Math.abs(lx-x)+Math.abs(lz-z)+Math.abs(ly-(h+4))<=2) createBlock(lx,ly,lz,5);
                        } else if(biome==='desert') {
                            // Cactus
                            for(let i=1;i<4;i++) createBlock(x,h+i,z,23);
                        } else if(biome==='mountain' && Math.random()<0.3) {
                            createBlock(x,h+1,z,27); // Candy Cane
                        }
                    }
                    if(Math.random()<0.005 && biome==='plains') createBlock(x,h+1,z,15); // Pumpkin
                }
            }
        }

        function updateChunks() {
            const pcx = Math.floor(player.position.x / CHUNK_SIZE);
            const pcz = Math.floor(player.position.z / CHUNK_SIZE);
            
            // Load
            for(let x = pcx - RENDER_DIST; x <= pcx + RENDER_DIST; x++) {
                for(let z = pcz - RENDER_DIST; z <= pcz + RENDER_DIST; z++) {
                    const k = `${x},${z}`;
                    if(!chunks.has(k)) {
                        genChunk(x, z);
                    }
                }
            }

            // Unload (aggressive for perf)
            for(let [k, meshes] of chunks) {
                const [cx, cz] = k.split(',').map(Number);
                if (Math.abs(cx - pcx) > RENDER_DIST + 1 || Math.abs(cz - pcz) > RENDER_DIST + 1) {
                    meshes.forEach(m => {
                        scene.remove(m);
                        if(m.userData.light) scene.remove(m.userData.light);
                        blockData.delete(m.userData.key);
                    });
                    chunks.delete(k);
                }
            }
        }

        // --- GAME LOOP & LOGIC ---
        let timeOfDay = 0; // 0..1
        const CYCLE_LEN = 240; // seconds total
        
        function updateSky(dt) {
            timeOfDay += dt / CYCLE_LEN;
            if(timeOfDay > 1) timeOfDay = 0;

            const sunH = Math.sin((timeOfDay - 0.25) * Math.PI * 2);
            const isNight = sunH < -0.2;
            
            // Color interpolation (Simplified)
            let skyCol = new THREE.Color(0x87CEEB);
            if (sunH < 0.1 && sunH > -0.1) skyCol.setHex(0xffaa00); // Sunset/Rise
            else if (isNight) skyCol.setHex(0x000011); // Night
            
            scene.background.lerp(skyCol, dt);
            if(scene.fog) scene.fog.color.copy(scene.background); // Safety check
            
            // Sun pos
            sunLight.position.x = Math.cos((timeOfDay-0.25)*Math.PI*2) * 100;
            sunLight.position.y = sunH * 100;
            sunLight.intensity = Math.max(0, sunH);
            ambLight.intensity = Math.max(0.1, sunH * 0.6);
            
            stars.material.opacity = isNight ? 1 : 0;

            // UI Text
            const hours = Math.floor(timeOfDay * 24);
            const mins = Math.floor((timeOfDay * 24 * 60) % 60);
            document.getElementById('time-display').innerText = `${hours}:${mins.toString().padStart(2,'0')}`;
        }

        // Mob Logic
        let chirpState = 'follow';
        function updateChirp(dt) {
            const dist = player.position.distanceTo(chirp.position);
            
            if (chirpState === 'follow') {
                if (dist > 3) {
                    const dir = new THREE.Vector3().subVectors(player.position, chirp.position).normalize();
                    chirp.position.addScaledVector(dir, dt * 3);
                    chirp.lookAt(player.position);
                    
                    // Simple hop
                    chirp.position.y = Math.abs(Math.sin(Date.now()/200)) * 0.5 + getGroundY(chirp.position.x, chirp.position.z);
                } else {
                    chirp.position.y = getGroundY(chirp.position.x, chirp.position.z);
                }
            }
        }

        function getGroundY(x, z) {
            // Very hacky ground check: raycast down?
            // Since we have blockData, we can probe
            const ix = Math.round(x), iz = Math.round(z);
            for(let y=10; y>-10; y--) {
                if(blockData.has(`${ix},${y},${iz}`)) return y + 1.3;
            }
            return 0;
        }

        // Petting
        document.addEventListener('keydown', e => {
            if(e.code === 'KeyE') {
                const ray = new THREE.Raycaster();
                ray.setFromCamera(new THREE.Vector2(0,0), camera);
                const hits = ray.intersectObject(chirp, true);
                if(hits.length > 0 && hits[0].distance < 4) {
                    playSound('chirp');
                    // Particles
                    for(let i=0; i<5; i++) spawnParticles(chirp.position, 0xff0000);
                }
            }
        });

        // Raycasting for blocks
        let selBlock = null;
        const raycaster = new THREE.Raycaster();
        raycaster.far = 6;
        
        function updateSelect() {
            raycaster.setFromCamera(new THREE.Vector2(0,0), camera);
            // Convert map values to array for raycast (slow, but works for demo)
            // Opt: raycast nearby chunks only
            const nearby = [];
            const pcx = Math.floor(player.position.x/CHUNK_SIZE), pcz = Math.floor(player.position.z/CHUNK_SIZE);
            const k = `${pcx},${pcz}`;
            if(chunks.has(k)) nearby.push(...chunks.get(k));
            
            const hits = raycaster.intersectObjects(nearby);
            if(hits.length > 0) selBlock = hits[0];
            else selBlock = null;
            
            const msg = document.getElementById('pet-msg');
            const chirpHit = raycaster.intersectObject(chirp, true);
            msg.style.opacity = (chirpHit.length > 0 && chirpHit[0].distance < 4) ? 1 : 0;
        }

        // Controls
        const keys = {};
        document.onkeydown = e => keys[e.code] = true;
        document.onkeyup = e => keys[e.code] = false;
        
        let vy = 0;
        let isGrounded = false;
        
        function updatePhysics(dt) {
            const speed = 6;
            const dir = new THREE.Vector3();
            const fwd = new THREE.Vector3(0,0,-1).applyQuaternion(player.quaternion);
            const right = new THREE.Vector3(1,0,0).applyQuaternion(player.quaternion);
            
            if(keys['KeyW']) dir.add(fwd);
            if(keys['KeyS']) dir.sub(fwd);
            if(keys['KeyA']) dir.sub(right);
            if(keys['KeyD']) dir.add(right);
            
            if(dir.lengthSq() > 0) {
                dir.normalize();
                player.position.addScaledVector(dir, speed * dt);
                // Step sound
                if(Math.sin(Date.now()/150) > 0.9 && isGrounded) playSound('step');
            }

            // Simple gravity
            vy -= 25 * dt;
            player.position.y += vy * dt;
            
            // Floor check
            const ground = getGroundY(player.position.x, player.position.z);
            if (player.position.y < ground) {
                player.position.y = ground;
                vy = 0;
                isGrounded = true;
            } else {
                isGrounded = false;
            }

            if(keys['Space'] && isGrounded) { vy = 9; isGrounded = false; }
            if(player.position.y < -20) player.position.set(0, 20, 0); // Void reset
        }

        document.onmousedown = e => {
            if(!document.pointerLockElement) return;
            hand.rotation.x = -0.5; setTimeout(()=>hand.rotation.x=0, 100);
            
            if(selBlock) {
                if(e.button === 0) {
                    // Break
                    const mesh = selBlock.object;
                    scene.remove(mesh);
                    if(mesh.userData.light) scene.remove(mesh.userData.light);
                    blockData.delete(mesh.userData.key);
                    // Remove from chunk array? Lazy cleanup or find index
                    spawnParticles(mesh.position, 0x888888);
                    playSound('break');
                } else if(e.button === 2) {
                    // Place
                    const p = selBlock.point.add(selBlock.face.normal.multiplyScalar(0.5)).floor().addScalar(0.5);
                    const selId = hotbar[selIdx];
                    createBlock(p.x, p.y, p.z, selId);
                    playSound('place');
                }
            }
        };
        
        document.onmousemove = e => {
            if(document.pointerLockElement) {
                player.rotation.y -= e.movementX * 0.002;
                head.rotation.x -= e.movementY * 0.002;
                head.rotation.x = Math.max(-1.5, Math.min(1.5, head.rotation.x));
            }
        };

        // Inventory
        const hotbar = [1, 2, 3, 4, 15, 16, 17, 25, 27, 12, 14, 28]; // Block IDs
        let selIdx = 0;
        const hbEl = document.getElementById('hotbar');
        
        hotbar.forEach((id, i) => {
            const d = document.createElement('div');
            d.className = `slot ${i===0?'active':''}`;
            d.innerHTML = `<div class="item-icon ${BLOCKS[id].icon}"></div>`;
            d.onclick = () => { selIdx = i; updateHB(); };
            hbEl.appendChild(d);
        });
        
        function updateHB() {
            Array.from(hbEl.children).forEach((c,i) => c.classList.toggle('active', i===selIdx));
        }
        document.addEventListener('wheel', e => {
            selIdx = (selIdx + Math.sign(e.deltaY) + hotbar.length) % hotbar.length;
            updateHB();
        });

        // Particles
        const parts = [];
        function spawnParticles(pos, col) {
            const geo = new THREE.BoxGeometry(0.1,0.1,0.1);
            const mat = new THREE.MeshBasicMaterial({color:col});
            for(let i=0; i<5; i++) {
                const p = new THREE.Mesh(geo, mat);
                p.position.copy(pos).addScalar((Math.random()-0.5));
                p.userData = { vy: Math.random()*5, life: 1 };
                scene.add(p);
                parts.push(p);
            }
        }

        // Loop
        let lastT = performance.now();
        function animate() {
            requestAnimationFrame(animate);
            const now = performance.now();
            const dt = Math.min((now - lastT)/1000, 0.1);
            lastT = now;

            if(document.pointerLockElement) {
                updatePhysics(dt);
                updateChunks();
                updateSelect();
                updateChirp(dt);
            }
            updateSky(dt);

            // Part
            for(let i=parts.length-1; i>=0; i--) {
                const p = parts[i];
                p.position.y += p.userData.vy * dt;
                p.userData.vy -= 10 * dt;
                p.userData.life -= dt;
                if(p.userData.life <= 0) { scene.remove(p); parts.splice(i,1); }
            }

            renderer.render(scene, camera);
        }

        // Init
        document.getElementById('health-bar').innerHTML = new Array(5).fill('<img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxMCAxMCI+PHBhdGggZD0iTTIgMWgydjFoMlYxaDJ2M2wtMSAxdjFsLTEgMXYxbC0xIDF2MWgtMnYtMWwtMS0xdi0xbC0xLTF2LTFsLTEtMVYxeiIgZmlsbD0icmVkIiBzdHJva2U9ImJsYWNrIiBzdHJva2Utd2lkdGg9IjAuNSIvPjwvc3ZnPg==" class="heart">').join('');
        document.getElementById('armor-bar').innerHTML = new Array(4).fill('<img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxMCAxMCI+PHBhdGggZD0iTTIgMWg2djFoMXYxaC0xdjFoMXYxaC0xdjFsLTEgMXYxbC0xIDFoLTJsLTEtMXYtMWwtMS0xdi0xaC0xdi0xaDF2LTFoLTFWMWgxeiIgZmlsbD0iZ3JheSIgc3Ryb2tlPSJibGFjayIgc3Ryb2tlLXdpZHRoPSIwLjUiLz48L3N2Zz4=" class="shield">').join('');

        // Safe Pointer Lock
        function requestSafePointerLock() {
            try {
                const promise = document.body.requestPointerLock();
                if (promise) {
                    promise.catch(err => console.warn("Pointer lock rejected:", err));
                }
            } catch (e) {
                console.warn("Pointer lock failed:", e);
            }
        }

        function startGame() {
            document.getElementById('main-menu').style.display = 'none';
            requestSafePointerLock();
            genChunk(0,0);
            player.position.set(0, 10, 0);
            animate();
        }
        
        window.onresize = () => { camera.aspect = window.innerWidth/window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); };

    </script>
</body>
</html>
