<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chirpless - Combat Update</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=VT323&display=swap');
        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'VT323', monospace; user-select: none; }
        
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; display: flex; flex-direction: column; justify-content: space-between; z-index: 10; }
        
        /* HUD */
        #hud-top { padding: 20px; display: flex; justify-content: space-between; align-items: flex-start; pointer-events: none; }
        #hud-left { display: flex; flex-direction: column; gap: 10px; }
        #hud-right { display: flex; flex-direction: column; gap: 10px; align-items: flex-end; }
        
        .stat-row { display: flex; gap: 5px; }
        .heart, .shield { width: 24px; height: 24px; image-rendering: pixelated; filter: drop-shadow(2px 2px 0 #000); }
        #time-display { color: white; font-size: 24px; text-shadow: 2px 2px 0 #000; background: rgba(0,0,0,0.3); padding: 5px 10px; border-radius: 4px; width: fit-content; }
        #fps-counter { color: #00ff00; font-size: 20px; text-shadow: 1px 1px 0 #000; font-family: monospace; }

        /* MINIMAP */
        #minimap-container {
            width: 130px; height: 130px; border: 4px solid #333; background: rgba(0,0,0,0.6);
            border-radius: 50%; overflow: hidden; position: relative;
            box-shadow: 0 4px 10px rgba(0,0,0,0.5); backdrop-filter: blur(2px);
        }
        #minimap { width: 100%; height: 100%; image-rendering: pixelated; }
        #minimap-arrow {
            position: absolute; top: 50%; left: 50%; width: 0; height: 0;
            border-left: 6px solid transparent; border-right: 6px solid transparent; border-bottom: 10px solid white;
            transform: translate(-50%, -50%); z-index: 2; filter: drop-shadow(0 1px 2px black);
        }

        #crosshair {
            position: absolute; top: 50%; left: 50%; width: 24px; height: 24px;
            background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path d="M11 0h2v24h-2zM0 11h24v2h-24z" fill="white" fill-opacity="0.9"/></svg>');
            transform: translate(-50%, -50%); mix-blend-mode: difference; z-index: 10; opacity: 0.8;
        }

        #hotbar-container { display: flex; flex-direction: column; align-items: center; padding-bottom: 15px; width: 100%; }
        #hotbar { display: flex; gap: 8px; background: rgba(0,0,0,0.6); padding: 8px; border-radius: 8px; pointer-events: auto; backdrop-filter: blur(2px); border: 1px solid rgba(255,255,255,0.1); }
        
        .slot {
            width: 50px; height: 50px; background: #8b8b8b; border: 3px solid #373737;
            display: flex; justify-content: center; align-items: center; position: relative; cursor: pointer; transition: transform 0.1s;
        }
        .slot.active { border-color: white; background: #a0a0a0; transform: scale(1.1); box-shadow: 0 0 15px rgba(255,255,255,0.4); z-index: 2; }
        .item-icon { width: 32px; height: 32px; image-rendering: pixelated; box-shadow: 2px 2px 0 rgba(0,0,0,0.3); }
        .slot-num { position: absolute; top: 2px; left: 4px; font-size: 14px; color: rgba(255,255,255,0.7); text-shadow: 1px 1px 0 #000; }

        /* DAMAGE FLASH */
        #damage-overlay {
            position: absolute; top:0; left:0; width:100%; height:100%;
            background: red; opacity: 0; pointer-events: none; transition: opacity 0.1s; z-index: 5;
        }

        /* MENUS */
        .overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.7); z-index: 50; display: none;
            flex-direction: column; justify-content: center; align-items: center;
            pointer-events: auto; backdrop-filter: blur(5px); color: white;
        }
        #main-menu { background: rgba(0,0,0,0.3); display: flex; }
        
        .logo { font-size: 100px; text-shadow: 0 5px 0 #222; margin-bottom: 20px; font-weight: bold; }
        .menu-box {
            background: rgba(0,0,0,0.6); padding: 40px; border-radius: 16px; border: 2px solid rgba(255,255,255,0.1);
            display: flex; flex-direction: column; gap: 15px; width: 350px; text-align: center;
        }
        .menu-btn { 
            padding: 12px; background: #4caf50; border: none; border-bottom: 4px solid #1b5e20; 
            color: white; font-size: 24px; cursor: pointer; font-family: inherit; border-radius: 6px; 
        }
        .menu-btn:hover { transform: translateY(-2px); }
        .menu-btn.red { background: #d32f2f; border-bottom-color: #b71c1c; }

        /* INVENTORY */
        .inv-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(50px, 1fr)); gap: 8px; width: 600px; height: 400px; overflow-y: auto; background: #8b8b8b; padding: 10px; border: 2px solid #333; }
        .inv-slot { width: 50px; height: 50px; background: #999; border: 2px solid #555; cursor: pointer; display: flex; justify-content: center; align-items: center; }
        
        #pet-msg { position: absolute; bottom: 140px; width: 100%; text-align: center; color: #ffd700; font-size: 28px; text-shadow: 2px 2px 0 #000; opacity: 0; }
        
        /* ICONS */
        .icon-sword { 
            background: linear-gradient(45deg, transparent 40%, #00e5ff 40%, #00e5ff 60%, transparent 60%); 
            position: relative; 
        }
        .icon-sword::after {
            content:''; position: absolute; left: 10px; bottom: 10px; width: 12px; height: 12px; background: #5d4037; transform: rotate(45deg);
        }
    </style>
</head>
<body>

    <div id="damage-overlay"></div>

    <div id="ui-layer">
        <div id="hud-top">
            <div id="hud-left">
                <div class="stat-row" id="health-bar"></div>
                <div class="stat-row" id="armor-bar"></div>
                <div id="time-display">Day 1 - 12:00 PM</div>
            </div>
            <div id="hud-right">
                <div id="fps-counter">FPS: 60</div>
                <div id="minimap-container">
                    <canvas id="minimap" width="60" height="60"></canvas>
                    <div id="minimap-arrow"></div>
                </div>
            </div>
        </div>
        <div id="pet-msg">Press 'E' to Pet Chirp</div>
        <div id="hotbar-container">
            <div id="hotbar"></div>
        </div>
    </div>

    <!-- INVENTORY -->
    <div id="inventory-overlay" class="overlay">
        <div class="menu-box" style="width: 650px; background: #c6c6c6; color: #333;">
            <div style="font-size:32px; display:flex; justify-content:space-between; border-bottom:2px solid #555; width:100%;">
                <span>Creative</span> <span style="cursor:pointer;" onclick="toggleInventory()">[X]</span>
            </div>
            <div class="inv-grid" id="inv-grid"></div>
        </div>
    </div>

    <!-- PAUSE MENU -->
    <div id="pause-menu" class="overlay">
        <div class="logo" style="font-size: 60px;">PAUSED</div>
        <div class="menu-box">
            <button class="menu-btn" onclick="resumeGame()">RESUME</button>
            <button class="menu-btn" onclick="saveGame()">SAVE GAME</button>
            <button class="menu-btn" onclick="loadGame()">LOAD GAME</button>
            <button class="menu-btn red" onclick="location.reload()">QUIT</button>
        </div>
    </div>

    <!-- DEATH SCREEN -->
    <div id="death-menu" class="overlay" style="background: rgba(50, 0, 0, 0.8);">
        <div class="logo" style="color: red;">YOU DIED!</div>
        <div class="menu-box">
            <div style="color: #fff; font-size: 24px;">A Zombie got you!</div>
            <button class="menu-btn" onclick="respawn()">RESPAWN</button>
        </div>
    </div>

    <!-- MAIN MENU -->
    <div id="main-menu" class="overlay" style="display: flex;">
        <div class="logo">CHIRPLESS</div>
        <div class="menu-box">
            <div style="color:#ddd; font-size: 18px;">ENTER WORLD SEED</div>
            <input type="text" id="seed-input" style="padding:10px; font-size:20px; text-align:center;" placeholder="12345" value="12345">
            <button class="menu-btn" onclick="startGame()">NEW GAME</button>
            <button class="menu-btn" style="background:#2196f3; border-color:#0d47a1;" onclick="loadGame(true)">LOAD SAVE</button>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <script>
        // --- CONSTANTS ---
        const PLAYER_HEIGHT = 1.8;
        const PLAYER_WIDTH = 0.6;
        const CHUNK_SIZE = 16;
        
        // --- TEXTURE GEN ---
        function genTex(color, type='noise') {
            const cvs = document.createElement('canvas');
            cvs.width = 64; cvs.height = 64;
            const ctx = cvs.getContext('2d');
            ctx.fillStyle = color; ctx.fillRect(0,0,64,64);
            if (type==='noise') {
                for(let i=0; i<400; i++) { ctx.fillStyle=`rgba(0,0,0,${Math.random()*0.15})`; ctx.fillRect(Math.random()*64, Math.random()*64,2,2); }
            } else if (type==='brick') {
                ctx.fillStyle='rgba(0,0,0,0.2)'; for(let y=0;y<64;y+=16){ ctx.fillRect(0,y,64,2); for(let x=(y/16)%2===0?0:32;x<64;x+=32) ctx.fillRect(x,y,2,16); }
            }
            const tex = new THREE.CanvasTexture(cvs); tex.magFilter = THREE.NearestFilter; return tex;
        }
        
        const TEX = {
            dirt: genTex('#5c4033'), grass_top: genTex('#5d9e44'), grass_side: genTex('#5d9e44'),
            stone: genTex('#757575'), wood: genTex('#4e342e', 'brick'), leaves: genTex('#2e7d32'),
            brick: genTex('#8d6e63', 'brick'), glass: genTex('#e0f7fa', 'noise'),
            pumpkin: genTex('#fb8c00', 'brick'), glow: genTex('#ffeb3b'),
            diamond_sword: genTex('#00e5ff', 'noise') // Placeholder texture
        };
        // Fix grass side
        const gsc = document.createElement('canvas'); gsc.width=64; gsc.height=64;
        const gcx = gsc.getContext('2d'); gcx.fillStyle='#5c4033'; gcx.fillRect(0,0,64,64); gcx.fillStyle='#5d9e44'; gcx.fillRect(0,0,64,20);
        TEX.grass_side = new THREE.CanvasTexture(gsc); TEX.grass_side.magFilter=THREE.NearestFilter;

        const BLOCKS = [
            { id: 0, name: 'Air', col: '#000' },
            { id: 1, name: 'Grass', tex: [TEX.grass_side, TEX.grass_side, TEX.grass_top, TEX.dirt, TEX.grass_side, TEX.grass_side], col: '#5d9e44' },
            { id: 2, name: 'Dirt', tex: TEX.dirt, col: '#5c4033' },
            { id: 3, name: 'Stone', tex: TEX.stone, col: '#757575' },
            { id: 4, name: 'Wood', tex: TEX.wood, col: '#4e342e' },
            { id: 5, name: 'Leaves', tex: TEX.leaves, col: '#2e7d32' },
            { id: 6, name: 'Bricks', tex: TEX.brick, col: '#8d6e63' },
            { id: 7, name: 'Glass', tex: TEX.glass, trans:true, col: '#e0f7fa' },
            { id: 8, name: 'Pumpkin', tex: TEX.pumpkin, col: '#fb8c00' },
            { id: 9, name: 'Glowstone', tex: TEX.glow, light: 0xffaa00, col: '#ffeb3b' },
            { id: 99, name: 'Diamond Sword', tex: TEX.diamond_sword, icon: 'icon-sword', isItem: true }
        ];

        // --- THREE JS ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87CEEB);
        scene.fog = new THREE.Fog(0x87CEEB, 20, 60);
        const camera = new THREE.PerspectiveCamera(70, window.innerWidth/window.innerHeight, 0.1, 100);
        const renderer = new THREE.WebGLRenderer({ antialias: false });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        document.body.appendChild(renderer.domElement);

        const ambLight = new THREE.AmbientLight(0xffffff, 0.4); scene.add(ambLight);
        const sunLight = new THREE.DirectionalLight(0xffffff, 0.8);
        sunLight.position.set(50, 100, 50); sunLight.castShadow = true;
        sunLight.shadow.mapSize.width = 1024; sunLight.shadow.mapSize.height = 1024;
        scene.add(sunLight);

        // Player
        const player = new THREE.Group(); scene.add(player);
        const head = new THREE.Group(); head.position.y = 1.6; player.add(head); head.add(camera);
        
        // Hand / Sword
        const handGroup = new THREE.Group();
        handGroup.position.set(0.4, -0.4, -0.6);
        head.add(handGroup);
        
        const armMesh = new THREE.Mesh(new THREE.BoxGeometry(0.2, 0.2, 0.6), new THREE.MeshLambertMaterial({color:0xeebb99}));
        armMesh.position.z = 0.2;
        
        // Sword Model
        const swordGroup = new THREE.Group();
        const blade = new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.6, 0.05), new THREE.MeshPhongMaterial({color: 0x00e5ff, shininess: 100}));
        blade.position.y = 0.4;
        const guard = new THREE.Mesh(new THREE.BoxGeometry(0.3, 0.05, 0.05), new THREE.MeshLambertMaterial({color: 0x00aaaa}));
        guard.position.y = 0.1;
        const handle = new THREE.Mesh(new THREE.BoxGeometry(0.08, 0.2, 0.05), new THREE.MeshLambertMaterial({color: 0x5d4037}));
        swordGroup.add(blade, guard, handle);
        swordGroup.rotation.x = Math.PI / 4;
        swordGroup.position.set(0, 0.1, -0.3);
        
        handGroup.add(armMesh); // Default arm

        // --- WORLD ---
        const blockData = new Map();
        const boxGeo = new THREE.BoxGeometry(1,1,1);
        const matCache = [];

        function getMat(id) {
            if(matCache[id]) return matCache[id];
            const b = BLOCKS[id];
            let m;
            if(Array.isArray(b.tex)) m = b.tex.map(t => new THREE.MeshLambertMaterial({map:t}));
            else m = new THREE.MeshLambertMaterial({map:b.tex, transparent:!!b.trans, opacity:b.trans?0.6:1});
            if(b.light) { const c=new THREE.Color(b.light); if(Array.isArray(m)) m.forEach(x=>x.emissive=c); else m.emissive=c; }
            matCache[id]=m; return m;
        }

        function createBlock(x,y,z,id) {
            const k = `${x},${y},${z}`;
            if(blockData.has(k)) return;
            const mesh = new THREE.Mesh(boxGeo, getMat(id));
            mesh.position.set(x,y,z);
            mesh.userData = { id: id, key: k, isBlock: true };
            scene.add(mesh);
            blockData.set(k, mesh);
            if(BLOCKS[id].light) {
                const l = new THREE.PointLight(BLOCKS[id].light, 1, 8);
                l.position.set(x,y,z); scene.add(l); mesh.userData.light = l;
            }
        }

        // --- MOBS (ZOMBIES) ---
        const zombies = [];
        const zombieGeo = new THREE.BoxGeometry(0.6, 1.8, 0.6);
        const zombieMat = new THREE.MeshLambertMaterial({color: 0x2e7d32}); // Green
        
        function spawnZombie() {
            // Find spot
            const angle = Math.random() * Math.PI * 2;
            const dist = 15 + Math.random() * 15;
            const zx = Math.round(player.position.x + Math.cos(angle)*dist);
            const zz = Math.round(player.position.z + Math.sin(angle)*dist);
            // Find ground
            let zy = 0;
            for(let y=20; y>-5; y--) {
                if(blockData.has(`${zx},${y},${zz}`)) { zy = y+2; break; }
            }
            if(zy > 0) {
                const zomb = new THREE.Group();
                const body = new THREE.Mesh(zombieGeo, zombieMat);
                body.position.y = 0.9;
                
                // Arms
                const arm = new THREE.Mesh(new THREE.BoxGeometry(0.2, 0.8, 0.2), zombieMat);
                arm.position.set(0.4, 1.2, 0.4); arm.rotation.x = -Math.PI/2;
                const arm2 = arm.clone(); arm2.position.set(-0.4, 1.2, 0.4);
                
                zomb.add(body, arm, arm2);
                zomb.position.set(zx, zy, zz);
                zomb.userData = { hp: 3, lastHit: 0 };
                scene.add(zomb);
                zombies.push(zomb);
            }
        }

        function updateZombies(dt) {
            const isNight = sunLight.position.y < 0;
            if(isNight && zombies.length < 5 && Math.random() < 0.01) spawnZombie();

            zombies.forEach((z, i) => {
                const dist = z.position.distanceTo(player.position);
                if(dist < 20) {
                    // Move
                    const dir = new THREE.Vector3().subVectors(player.position, z.position).normalize();
                    dir.y = 0;
                    
                    // Simple collision avoidance with blocks (jump)
                    const fwd = z.position.clone().add(dir.clone().multiplyScalar(0.5));
                    if(blockData.has(`${Math.round(fwd.x)},${Math.round(z.position.y)},${Math.round(fwd.z)}`)) {
                        z.position.y += 5 * dt; // Jump
                    }
                    
                    z.position.addScaledVector(dir, 2.5 * dt); // Speed
                    z.lookAt(player.position);
                    
                    // Gravity
                    const gy = getBlockBelow(z.position);
                    if(z.position.y > gy) z.position.y -= 10 * dt;
                    else z.position.y = gy;

                    // Attack
                    if(dist < 1.0) {
                        takeDamage(1);
                        // Knockback player
                        const kb = dir.clone().multiplyScalar(5);
                        velocity.add(kb);
                    }
                } else if (!isNight && dist > 40) {
                    scene.remove(z);
                    zombies.splice(i, 1);
                }
            });
        }

        function getBlockBelow(pos) {
            const bx = Math.round(pos.x);
            const bz = Math.round(pos.z);
            for(let y=Math.ceil(pos.y); y>-10; y--) {
                if(blockData.has(`${bx},${y},${bz}`)) return y + 1.0;
            }
            return -10;
        }

        // --- GAME LOGIC ---
        let health = 5;
        let invuln = 0;
        
        function takeDamage(amt) {
            if(Date.now() < invuln) return;
            health -= amt;
            invuln = Date.now() + 1000;
            
            // UI Update
            document.getElementById('health-bar').innerHTML = new Array(Math.max(0, health)).fill('<img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxMCAxMCI+PHBhdGggZD0iTTIgMWgydjFoMlYxaDJ2M2wtMSAxdjFsLTEgMXYxbC0xIDF2MWgtMnYtMWwtMS0xdi0xbC0xLTF2LTFsLTEtMVYxeiIgZmlsbD0icmVkIiBzdHJva2U9ImJsYWNrIiBzdHJva2Utd2lkdGg9IjAuNSIvPjwvc3ZnPg==" class="heart">').join('');
            
            // Flash
            const ol = document.getElementById('damage-overlay');
            ol.style.opacity = 0.5;
            setTimeout(() => ol.style.opacity = 0, 200);

            if(health <= 0) {
                document.exitPointerLock();
                document.getElementById('death-menu').style.display = 'flex';
                isPlaying = false;
            }
        }

        function hitZombie() {
            // Raycast for mobs
            const ray = new THREE.Raycaster();
            ray.setFromCamera(new THREE.Vector2(0,0), camera);
            const hits = ray.intersectObjects(zombies, true); // Recursive for groups
            
            if(hits.length > 0 && hits[0].distance < 3.5) {
                // Find root group
                let target = hits[0].object;
                while(target.parent !== scene) target = target.parent;
                
                target.userData.hp--;
                // Knockback
                const dir = new THREE.Vector3().subVectors(target.position, player.position).normalize();
                target.position.addScaledVector(dir, 2);
                target.children[0].material.color.setHex(0xff0000); // Flash red
                setTimeout(()=>target.children[0].material.color.setHex(0x2e7d32), 100);

                if(target.userData.hp <= 0) {
                    scene.remove(target);
                    zombies.splice(zombies.indexOf(target), 1);
                }
                
                // Swing animation
                handGroup.rotation.x = -1; 
                setTimeout(()=>handGroup.rotation.x=0, 200);
            }
        }

        // --- COLLISION PHYSICS (FIXED) ---
        let velocity = new THREE.Vector3();
        
        function hasBlock(x, y, z) {
            return blockData.has(`${Math.round(x)},${Math.round(y)},${Math.round(z)}`);
        }

        function checkCollision(pos) {
            // Simple point check + radius? Or 2-point check (feet/head)
            // Player is ~0.6 wide, 1.8 tall.
            // We check feet, waist, head.
            const r = 0.25; // radius
            const points = [
                new THREE.Vector3(pos.x, pos.y, pos.z), // feet
                new THREE.Vector3(pos.x, pos.y + 0.9, pos.z), // waist
                new THREE.Vector3(pos.x, pos.y + 1.7, pos.z) // head
            ];
            
            // Check center and corners of player box
            for(let p of points) {
                if(hasBlock(p.x, p.y, p.z)) return true;
                if(hasBlock(p.x + r, p.y, p.z)) return true;
                if(hasBlock(p.x - r, p.y, p.z)) return true;
                if(hasBlock(p.x, p.y, p.z + r)) return true;
                if(hasBlock(p.x, p.y, p.z - r)) return true;
            }
            return false;
        }

        function updatePhysics(dt) {
            // WASD
            const speed = 6;
            const input = new THREE.Vector3();
            if(keys['KeyW']) input.z -= 1; if(keys['KeyS']) input.z += 1;
            if(keys['KeyA']) input.x -= 1; if(keys['KeyD']) input.x += 1;
            if(input.lengthSq() > 0) input.normalize();

            // Rot
            const yaw = player.rotation.y;
            const fwd = new THREE.Vector3(Math.sin(yaw), 0, Math.cos(yaw)); // -Z is forward? No, usually.
            // Correct mapping:
            // Camera looks down -Z. 
            // W moves -Z relative to rotation.
            const moveVec = new THREE.Vector3();
            moveVec.addScaledVector(new THREE.Vector3(Math.sin(yaw), 0, Math.cos(yaw)), -input.z); // Fwd/Back
            moveVec.addScaledVector(new THREE.Vector3(Math.cos(yaw), 0, -Math.sin(yaw)), input.x); // Strafe
            
            velocity.x = moveVec.x * speed;
            velocity.z = moveVec.z * speed;
            velocity.y -= 25 * dt; // Gravity

            // Apply X
            player.position.x += velocity.x * dt;
            if(checkCollision(player.position)) player.position.x -= velocity.x * dt;

            // Apply Z
            player.position.z += velocity.z * dt;
            if(checkCollision(player.position)) player.position.z -= velocity.z * dt;

            // Apply Y
            player.position.y += velocity.y * dt;
            if(checkCollision(player.position)) {
                // Determine direction
                if(velocity.y < 0) { // Landing
                    // Snap to grid top?
                    player.position.y = Math.ceil(player.position.y - 0.5); 
                    canJump = true;
                } else { // Hitting head
                    player.position.y = Math.floor(player.position.y);
                }
                velocity.y = 0;
            } else {
                canJump = false;
            }

            if(player.position.y < -30) respawn();
        }

        // --- CONTROLS ---
        const keys = {};
        let canJump = false;
        document.addEventListener('keydown', e => {
            keys[e.code] = true;
            if(isPlaying) {
                if(e.code === 'Space' && canJump) { velocity.y = 9; canJump = false; }
                if(e.key >= '1' && e.key <= '9') { selIdx = parseInt(e.key)-1; if(selIdx >= hotbar.length) selIdx=hotbar.length-1; updateHB(); }
                if(e.code === 'KeyE') toggleInventory();
            }
        });
        document.addEventListener('keyup', e => keys[e.code] = false);
        
        let selBlock = null;
        let hotbar = [99, 1, 2, 3, 4, 8, 9, 7, 5]; // 99 is Sword
        let selIdx = 0;
        let isPlaying = false;
        let isInventoryOpen = false;

        document.onmousedown = e => {
            if(!isPlaying || isInventoryOpen) return;
            if(!document.pointerLockElement) { document.body.requestPointerLock(); return; }
            
            // Swing animation
            handGroup.rotation.x = -1; setTimeout(()=>handGroup.rotation.x=0, 150);

            // Item Logic
            const itemId = hotbar[selIdx];
            if(itemId === 99) {
                // Sword Attack
                hitZombie();
            } else if(selBlock) {
                // Block Logic
                if(e.button === 0) { // Break
                    scene.remove(selBlock.object);
                    if(selBlock.object.userData.light) scene.remove(selBlock.object.userData.light);
                    blockData.delete(selBlock.object.userData.key);
                } else if(e.button === 2) { // Place
                    // Prevent placing inside player
                    const p = selBlock.point.add(selBlock.face.normal.multiplyScalar(0.5)).floor().addScalar(0.5);
                    const dummy = { x: p.x, y: p.y-0.5, z: p.z }; // Check roughly 
                    if(Math.abs(dummy.x - player.position.x) < 0.8 && Math.abs(dummy.y - player.position.y) < 1.8 && Math.abs(dummy.z - player.position.z) < 0.8) return;
                    createBlock(p.x, p.y, p.z, itemId);
                }
            }
        };

        // --- MAIN LOOP ---
        function animate() {
            requestAnimationFrame(animate);
            if(!isPlaying) { renderer.render(scene,camera); return; }
            
            const dt = 0.016; // Fixed step approximation
            
            updatePhysics(dt);
            updateZombies(dt);
            
            // Raycast for block selection
            const ray = new THREE.Raycaster();
            ray.setFromCamera(new THREE.Vector2(0,0), camera);
            ray.far = 5;
            const hits = ray.intersectObjects(scene.children);
            const bHits = hits.filter(h => h.object.userData.isBlock);
            selBlock = bHits.length > 0 ? bHits[0] : null;

            // Sky
            const time = Date.now() * 0.0001; // Day cycle
            sunLight.position.y = Math.sin(time) * 100;
            sunLight.position.x = Math.cos(time) * 100;
            const isNight = sunLight.position.y < 0;
            scene.background.setHex(isNight ? 0x050510 : 0x87CEEB);
            scene.fog.color.copy(scene.background);
            sunLight.intensity = isNight ? 0 : 1;
            
            // Hand Model Swap
            const currentItem = hotbar[selIdx];
            handGroup.clear();
            if(currentItem === 99) handGroup.add(swordGroup); // Sword
            else handGroup.add(armMesh); // Block/Hand

            renderer.render(scene, camera);
        }

        // --- INIT ---
        function genWorld() {
            for(let x=-20; x<20; x++) {
                for(let z=-20; z<20; z++) {
                    const h = Math.floor(Math.sin(x/5)*3 + Math.cos(z/5)*3);
                    createBlock(x, -5, z, 0); // floor? No, 0 is air in my list but logic handles IDs. Actually 0 is air.
                    // Bedrock at -5
                    createBlock(x, -5, z, 3);
                    for(let y=-4; y<=h; y++) {
                        let id = 3;
                        if(y===h) id=1; else if(y>h-3) id=2;
                        createBlock(x,y,z,id);
                    }
                }
            }
        }

        function startGame() {
            document.getElementById('main-menu').style.display='none';
            document.body.requestPointerLock();
            genWorld();
            player.position.set(0, 10, 0);
            isPlaying = true;
            
            // Inventory Grid
            const inv = document.getElementById('inv-grid');
            inv.innerHTML = '';
            BLOCKS.forEach((b,i) => {
                if(i===0) return;
                const d = document.createElement('div'); d.className='inv-slot';
                d.style.backgroundColor = b.col; d.title = b.name;
                d.onclick = () => { hotbar[selIdx] = i; updateHB(); toggleInventory(); };
                inv.appendChild(d);
            });
            updateHB();
            animate();
        }

        function respawn() {
            health = 5;
            takeDamage(0); // Update UI
            player.position.set(0, 20, 0);
            document.getElementById('death-menu').style.display='none';
            document.body.requestPointerLock();
            isPlaying = true;
        }

        function toggleInventory() {
            isInventoryOpen = !isInventoryOpen;
            document.getElementById('inventory-overlay').style.display = isInventoryOpen ? 'flex' : 'none';
            if(isInventoryOpen) document.exitPointerLock(); else document.body.requestPointerLock();
        }

        function updateHB() {
            const h = document.getElementById('hotbar'); h.innerHTML='';
            hotbar.forEach((id, i) => {
                const d = document.createElement('div'); d.className = `slot ${i===selIdx?'active':''}`;
                const b = BLOCKS.find(x=>x.id===id);
                if(b) {
                    if(b.isItem) d.innerHTML = '<div class="item-icon icon-sword"></div>';
                    else d.style.backgroundColor = b.col;
                }
                d.innerHTML += `<div class="slot-num">${i+1}</div>`;
                h.appendChild(d);
            });
        }

        document.onmousemove = e => {
            if(document.pointerLockElement) {
                player.rotation.y -= e.movementX * 0.002;
                head.rotation.x -= e.movementY * 0.002;
                head.rotation.x = Math.max(-1.5, Math.min(1.5, head.rotation.x));
            }
        };
        
        window.onresize = () => { camera.aspect = window.innerWidth/window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); };
    </script>
</body>
</html>
